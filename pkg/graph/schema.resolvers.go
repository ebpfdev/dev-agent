package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"
	"sort"

	"github.com/cilium/ebpf"
	"github.com/ebpfdev/dev-agent/pkg/ebpf/maps"
	"github.com/ebpfdev/dev-agent/pkg/graph/generated"
	"github.com/ebpfdev/dev-agent/pkg/graph/model"
)

// Entries is the resolver for the entries field.
func (r *mapResolver) Entries(ctx context.Context, obj *model.Map, offset *int, limit *int, keyFormat *model.MapEntryFormat, valueFormat *model.MapEntryFormat) ([]*model.MapEntry, error) {
	mapEntries, err := maps.GetEntries(ebpf.MapID(obj.ID), false)
	if err != nil {
		return nil, err
	}

	modelEntries := make([]*model.MapEntry, 0)
	for _, mapEntry := range mapEntries.Entries {
		modelEntry := &model.MapEntry{
			Key: formatValue(*keyFormat, mapEntry.Key),
		}
		if len(mapEntry.Value) > 0 {
			value := formatValue(*valueFormat, mapEntry.Value)
			modelEntry.Value = &value
		}
		if len(mapEntry.CPUValues) > 0 {
			values := make([]string, len(mapEntry.CPUValues))
			for i, value := range mapEntry.CPUValues {
				values[i] = formatValue(*valueFormat, value)
			}
			modelEntry.CPUValues = values
		}
		modelEntries = append(modelEntries, modelEntry)
	}

	sort.SliceStable(modelEntries, func(i, j int) bool {
		return modelEntries[i].Key < modelEntries[j].Key
	})

	offsetStart := 0
	if offset != nil {
		offsetStart = *offset
	}
	limitValue := 32
	if limit != nil {
		limitValue = *limit
	}

	offsetEnd := offsetStart + limitValue
	if offsetEnd > len(modelEntries) {
		offsetEnd = len(modelEntries)
	}

	result := modelEntries[offsetStart:offsetEnd]

	return result, nil
}

// EntriesCount is the resolver for the entriesCount field.
func (r *mapResolver) EntriesCount(ctx context.Context, obj *model.Map) (int, error) {
	return maps.CountEntries(ebpf.MapID(obj.ID))
}

// Programs is the resolver for the programs field.
func (r *mapResolver) Programs(ctx context.Context, obj *model.Map) ([]*model.Program, error) {
	progs, err := r.ProgsRepository.GetProgs()
	if err != nil {
		return nil, err
	}
	result := make([]*model.Program, 0)
	for _, prog := range progs {
		mapIDs, _ := prog.Info.MapIDs()
		for _, mapID := range mapIDs {
			if mapID == ebpf.MapID(obj.ID) {
				result = append(result, progInfoToModel(&prog))
			}
		}
	}
	return result, nil
}

// Maps is the resolver for the maps field.
func (r *programResolver) Maps(ctx context.Context, obj *model.Program) ([]*model.Map, error) {
	emaps, err := r.MapsRepository.GetMaps()
	if err != nil {
		return nil, err
	}
	goodMaps := make(map[ebpf.MapID]*maps.MapInfo, 0)
	for _, info := range emaps {
		goodMaps[info.ID] = info
	}

	mapsResult := obj.Maps
	for i, m := range mapsResult {
		if goodMap, ok := goodMaps[ebpf.MapID(m.ID)]; ok {
			mapsResult[i] = mapInfoToModel(goodMap)
		} else {
			errMsg := fmt.Sprintf("map with ID %d not found", m.ID)
			mapsResult[i] = &model.Map{
				ID:    m.ID,
				Error: &errMsg,
			}
		}
	}
	return mapsResult, nil
}

// Tasks is the resolver for the tasks field.
func (r *programResolver) Tasks(ctx context.Context, obj *model.Program) ([]*model.Task, error) {
	tasks, err := r.TasksRepository.GetTasks()
	if err != nil {
		return nil, err
	}
	result := make([]*model.Task, 0)
	for _, task := range tasks {
		if task.ProgramID == ebpf.ProgramID(obj.ID) {
			result = append(result, taskInfoToModel(task))
		}
	}
	return result, nil
}

// Program is the resolver for the program field.
func (r *queryResolver) Program(ctx context.Context, id int) (*model.Program, error) {
	prog, err := r.ProgsRepository.GetProg(ebpf.ProgramID(id))
	if err != nil {
		return nil, err
	}
	return progInfoToModel(prog), nil
}

// Programs is the resolver for the programs field.
func (r *queryResolver) Programs(ctx context.Context) ([]*model.Program, error) {
	progs, err := r.ProgsRepository.GetProgs()
	if err != nil {
		return nil, err
	}
	result := make([]*model.Program, len(progs))
	for i, prog := range progs {
		result[i] = progInfoToModel(&prog)
	}
	return result, nil
}

// Map is the resolver for the map field.
func (r *queryResolver) Map(ctx context.Context, id int) (*model.Map, error) {
	emap, err := r.MapsRepository.GetMap(ebpf.MapID(id))
	if err != nil {
		return nil, err
	}
	return mapInfoToModel(emap), nil
}

// Maps is the resolver for the maps field.
func (r *queryResolver) Maps(ctx context.Context) ([]*model.Map, error) {
	emaps, err := r.MapsRepository.GetMaps()
	if err != nil {
		return nil, err
	}
	result := make([]*model.Map, len(emaps))
	for i, m := range emaps {
		result[i] = mapInfoToModel(m)
	}
	return result, nil
}

// ConnectedGraph is the resolver for the connectedGraph field.
func (r *queryResolver) ConnectedGraph(ctx context.Context, from int, fromType model.IDType) (*model.ConnectedGraph, error) {
	progsMap, mapsMap, err := r.resolveConnectedGraph(from, fromType)
	if err != nil {
		return nil, err
	}
	return buildConnectedGraph(progsMap, mapsMap), nil
}

// Map returns generated.MapResolver implementation.
func (r *Resolver) Map() generated.MapResolver { return &mapResolver{r} }

// Program returns generated.ProgramResolver implementation.
func (r *Resolver) Program() generated.ProgramResolver { return &programResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mapResolver struct{ *Resolver }
type programResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
